---
title: 双亲委派模型应用及其规则的打破
date: 2023-09-11 20:38:43
tags: JVM虚拟机
---
> 本文整合《深入理解JAVA虚拟机》及自己的理解，若有错误敬请留言斧正。


# 双亲委派模型

## 双亲委派模型加载流程

**向上委派：** 当一个类被加载时，默认会调用**Application ClassLoader**，但AppClassLoader并不会直接加载该类，而是通过parent变量找到其父类加载器(**Extension ClassLoader**)，委托给其父类进行加载，ExtClassLoader会委托给**Bootstrap ClassLoader**，Bootstrap CLassLoader没有父类了。
**向下委派：**此时Bootstrap CLassLoader会对需要加载类尝试进行加载，如果无法加载则返回ExtClassLoader进行加载。同理，如果ExtClassLoader无法加载则返回AppClassLoader进行加载，如果AppClassLoader也无法加载则抛出ClassNotFoundException异常。上述过程有一个类加载器可以完成相关加载任务，则加载成功，存放其元数据并创建Class对象(JDK8之后Class对象是在堆区)。

## 类加载器各自负责加载的类

**Bootstrap CLassLoader：**负责加载你配置的环境变量JAVA_HOME/lib下的核心类库。
**Extension ClassLoader：**负责加载JAVA_HOME/lib/ext下的扩展类库。
**Application ClassLoader：**负责加载CLASSPATH下指定的类库。

## 类加载流程代码实现

```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先，查找该类是否已经被加载过
            Class<?> c = findLoadedClass(name);
            // 未被加载
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    // 有父加载器，就让父加载器去加载
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    // 没有父加载器，则让BootStrap加载器去加载
                    // 因为BootStrap类加载器没有父类加载器的
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // 父类无法加载，则自己调用 findClass 方法去加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

**总结loadClass的代码逻辑：**

1. 先检查请求加载的类型是否已经被加载过
2. 若没有则调用父加载器的loadClass()方法
3. 若父加载器为空则默认使用启动类加载器作为父加载器。
4. 假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。

## 双亲委派模型的好处

1. **防止加载同一个.class。** 通过委托去询问上级是否已经加载过该.class，如果加载过了，则不需要重新加载。保证了数据安全。
2. **保证核心.class不被篡改。** 通过委托的方式，保证核心.class不被篡改，即使被篡改也不会被加载，即使被加载也不会是同一个class对象，因为不同的加载器加载同一个.class也不是同一个Class对象。这样则保证了Class的执行安全。

# 打破双亲委派模型

## 为什么需要打破双亲委派模型

由于加载范围的限制带来的一些不灵活问题，导致此时需要破坏双亲委派模型。

## 打破双亲委派的经典示例

### Tomcat

Tomcat打破了双亲委派模型，具体解释这篇文章讲得很好，此处不赘述了：[Tomcat是如何打破"双亲委派"机制的?](https://developer.aliyun.com/article/1081332)

![](https://cdn.staticaly.com/gh/1294566108/1294566108.github.io@release/images/屏幕截图-2023-09-11-205720.1e9vt2ouitr4.webp)
那么为什么我们认为 Tomcat 打破了双亲委派模型呢？
因为 Web 应用默认的类加载顺序是（打破了双亲委派规则）：

1. 先在本地缓存中查找该类是否已经加载过，如果加载过就返回缓存中的。
2. 如果没有加载过，委托给AppClassLoader是否加载过，如果加载过就返回。
3. 如果AppClassLoader也没加载过，委托给ExtClassLoader去加载，这么做的目的就是：防止应用自己的类库覆盖了核心类库，因为WebAppClassLoader需要打破双亲委托机制，假如应用里自定义了一个叫java.lang.String的类，如果先加载这个类，就会覆盖核心类库的java.lang.String，所以说它会优先尝试用ExtClassLoader去加载，因为ExtClassLoader加载不到同样也会委托给BootstrapClassLoader去加载，也就避免了覆盖了核心类库的问题。
4. 如果ExtClassLoader也没有查找到，说明核心类库中没有这个类，那么就在本地应用目录下查找此类并加载。
5. 如果本地应用目录下还有没有这个类，那么肯定不是应用自己定义的类，那么就由AppClassLoader去加载。这里是通过Class.forName()调用AppClassLoader类加载器的，因为Class.forName()的默认加载器就是AppClassLoader。
6. 如果上述都没有找到，那么只能抛出ClassNotFoundException了。

### SPI的加载

SPI 是一种服务发现机制。它通过在ClassPath路径下的 **META-INF/services** 文件夹查找文件，自动加载文件里所定义的类。通过SPI机制可以让接口和实现类分离，服务提供者只提供接口，第三方来进行实现。SPI 的一个经典应用就是 JDBC，JAVA 只提供操作数据库的接口，而各个数据库厂商根据接口提供相应的实现，然后按照规则编写配置文件，使用者引入jar包就可以使用。
由于接口是写在JDK中的，而且是由Bootstrap Classloader来加载的，而实现类是作为第三方包来加载的(默认是AppClassloader来加载)，根据类的委派规则，Bootstrap Classloader是不能主动委托AppclassLoader来加载第三方包的。这个问题JDK是通过**线程上下文类加载器**来解决的。

### 代码热替换、模块热部署

关于这部分，此处不再赘述，这篇文章写得很详细：[热加载原理解析与实现](https://blog.51cto.com/u_14006572/5711336)
我们认为热部署打破双亲委派的原因是：
以OSGi为例，加载一个类可能发生的查找行为和委派关系会比上图中显示的复杂，类加载时的查找规则如下：

1. 以java.*开头的类，委派给父类加载器加载
2. 否则，委派列表名单内的类，委派给父类加载器加载
3. 否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载
4. 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载
5. 否则，查找是否在自己的Fragment Bundle中，如果是，则委派给Fragment bundle的类加载器加载
6. 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载
7. 否则，查找失败

在OSGi里面，加载器的关系不再是双亲委派模型的树形架构，而是已经进一步发展成了一种更复杂的、运行时才能确定的网状结构。

